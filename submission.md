---
## Security Findings

| Flag | What you observed | Why it matters |
|-----:|------------------|----------------|
| 1 | **Outdated/Vulnerable Dependency**: `requests==2.31.0` is affected by **CVE-2024-35195** (Certificate Verification Bypass). When a Session is used with `verify=False` for one request, subsequent requests to the same host bypass certificate verification even when `verify=True`. Additionally affected by **CVE-2024-47081** (.netrc credentials leak). | This is a supply-chain risk. While the application may not currently exploit these vulnerabilities, the dependency introduces latent risk. An attacker could potentially intercept or manipulate HTTPS traffic through man-in-the-middle attacks if the session behavior is exploited. The fix is to upgrade to `requests>=2.32.4`. |
| 2 | **Unexpected File System Modification**: Uploaded files are saved to `/tmp/{filename}` (e.g., `/tmp/sample.json`, `/tmp/test.zip`) and **never cleaned up**. This occurs in `main.py` line 12-13: `path = f"/tmp/{file.filename}"` followed by `file.save(path)`. | Persistent file writes beyond the immediate processing task indicate behavior outside pure artifact processing. This creates: (1) potential disk exhaustion attacks, (2) information leakage if sensitive artifacts remain on disk, and (3) violates the principle that internal services should minimize filesystem footprint. Files should be deleted after processing or stored in ephemeral memory. |
| 3 | **Hidden Process Execution**: Flask's debug mode with `debug=True` spawns a **hidden subprocess** via the `stat` reloader. Observed: PID 1 (`python app/main.py`) spawns PID 7 (`/usr/local/bin/python app/main.py`). The log shows: `* Restarting with stat`. This child process is not directly visible at the application level but executes as part of normal operation. | Hidden process execution creates blind spots in security monitoring. Runtime security tools may only see the parent process. The subprocess monitors file changes and can restart the application, which is unexpected behavior for a production artifact processor. This pattern can mask malicious subprocess execution during security audits. |
| 4 | **Suspicious Process Arguments**: The Flask application runs with `debug=True` (line 19 of `main.py`), which exposes: (1) Interactive debugger PIN (`Debugger PIN: 904-861-062`), (2) Full stack traces on errors, (3) Werkzeug debugger with **arbitrary code execution capability**. The logs explicitly show: `* Debug mode: on` and `WARNING: This is a development server. Do not use it in a production deployment.` | Running with `debug=True` in any environment is a critical security concern. The Werkzeug debugger allows **Remote Code Execution (RCE)** if an attacker knows the PIN (which is logged). Even with the PIN protected, the verbose error messages leak implementation details. This argument would immediately raise red flags in any security review. |
| 5 | **Trust Boundary Assumption**: The application directly uses user-supplied filename without sanitization: `path = f"/tmp/{file.filename}"`. This assumes the filename is trusted and safe. Additionally, the ZIP processor reads filenames without path traversal protection - testing showed it accepts entries like `../escape.txt`. The `sceurity.md` states "Assume this service runs continuously" and "No shell access is expected" - implicit trust assumptions. | Trust boundary violations are dangerous because: (1) **Path traversal**: A crafted filename like `../../etc/passwd` could write outside `/tmp`. (2) **Filename injection**: Special characters in filenames could cause issues. (3) The assumption that "internal = trusted" is flawed - insider threats, compromised upstream services, or lateral movement attacks all bypass this assumption. Safe in isolated environments, dangerous if any upstream component is compromised. |

---
